# Инструменты анализа производительности Tarantool по версиям

В этом документе представлен обзор инструментов для анализа производительности, мониторинга и профилирования для разных версий Tarantool.

## Tarantool 1.5 (Legacy)

Версия 1.5 полагается в основном на внутреннюю статистику и стандартные системные утилиты.

### Встроенные инструменты
*   **`box.stat`**: Базовая статистика (RPS, счетчики операций `INSERT`, `DELETE`, `SELECT`, `UPDATE`).
*   **`box.info`**: Общая информация о сервере и статусе репликации.

### Профайлеры
*   **`gperftools`**: Google Performance Tools (CPU profiler), можно использовать через Lua-биндинги.
*   **`jit.p`**: Встроенный профайлер LuaJIT (требует сборки LuaJIT со специальными флагами). Полезен для поиска горячих путей в Lua-коде.

### Внешние утилиты
*   **Системные**: `strace`, `pstack`, `gdb` — стандартный набор для отладки зависаний и проблем на уровне C.

---

## Tarantool 1.6

Появилась более детальная статистика по сети и памяти, а также зачатки экосистемы метрик.

### Встроенные инструменты
*   **`box.stat.net`**: Детальная статистика сети (объем трафика, соединения, потоки). **Появилась именно в 1.6**, в 1.5 отсутствовала.
*   **`box.slab.stats()`**: Детальная статистика слэб-аллокатора. Критически важна для понимания использования и фрагментации памяти под кортежи.

### Метрики
*   **Модуль Metrics (Early)**: Появился внешний модуль `metrics` с базовыми возможностями экспорта данных, но менее функциональный, чем современные версии.

---

## Tarantool 1.10 (LTS 1.x)

Стабильный стандарт. Сформировалась зрелая экосистема мониторинга.

### Метрики и Мониторинг
*   **Модуль `metrics`**: Стандартная библиотека для 1.10. Поддерживает экспорт в **Prometheus**, **Graphite** и JSON. Покрывает память, сеть, спейсы и файберы.
*   **Grafana Dashboards**: Доступны официальные дашборды для визуализации данных из связки `metrics` + Prometheus.

### Отладка и Профилирование
*   **`fiber.info()`**: Возвращает список всех файберов и их C-стеки. Незаменимо для поиска "тяжелых" файберов, блокирующих кооперативный event loop.
*   **`systool`**: Утилита для системного профилирования и инспекции.

---

## Tarantool 2.x

Эра продвинутых профайлеров. Инструментарий приближается к уровню Java или Go.

### Профайлеры (Новые)
*   **`misc.memprof` (2.7.1+)**: **Memory Profiler**. Отслеживает аллокации памяти Lua-объектов с привязкой к строкам исходного кода. Главный инструмент для поиска утечек памяти в Lua.
*   **`misc.sysprof` (2.10+)**: **System Profiler** (сэмплирующий). Профилирует исполнение как Lua, так и C кода. Умеет генерировать данные для **Flamegraphs**, позволяя увидеть, где тратится CPU: в бизнес-логике или внутри движка Tarantool.

### Метрики
*   **Встроенные метрики (2.11+)**: Модуль `metrics` включен в базовую поставку, установка через luarocks больше не обязательна.

---

## Tarantool 3.x (Modern)

Фокус на кластерных фичах, унификации и удобстве использования.

### Инструментарий
*   **`tt` CLI**: Единая консольная утилита.
    *   `tt connect`: Позволяет легко подключаться к инстансам для запуска сессий профилирования (`misc.sysprof` / `misc.memprof`) прямо через интерактивную Lua-консоль.

### Мониторинг
*   **Кластерные метрики**:
    *   **CRUD**: Трекинг задержек (latency) для CRUD-операций (критично для архитектур с роутерами).
    *   **Expirationd**: Мониторинг фоновых задач по удалению устаревших данных.
    *   **Синхронная репликация**: `box.info.synchro` дает детали по очереди и лагу синхронной репликации.

---

## Алгоритм поиска проблем (Walkthrough)

Для анализа проблем производительности на современных версиях (1.10+):

1.  **Check Basics**: Смотрим `box.stat` и `box.info` — есть ли нагрузка, жива ли репликация.
2.  **Check Latency**: Смотрим в **Grafana** (данные от `metrics`) — ищем всплески latency на конкретных ручках API.
3.  **Profile CPU**: Если CPU высокий -> запускаем `misc.sysprof` (или `jit.p` на старых версиях) и анализируем Flamegraph.
4.  **Profile Memory**: Если память течет (риск OOM) -> запускаем `misc.memprof` и ищем утечки в Lua-коде.
5.  **Check Fibers**: Если инстанс "висит", но CPU низкий (или забит одним ядром) -> проверяем `fiber.info()` на наличие блокирующих операций в event loop.
